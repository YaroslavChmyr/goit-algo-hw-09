# Порівняння алгоритмів знаходження мінімальної кількості монет для видачі решти

## Виконання порівняння

Для порівняння швидкодії обох алгоритмів використовувався модуль `timeit` Python. Кожен алгоритм був викликаний 100 разів для того ж набору монет та суми, щоб перевірити роботу алгоритмів з великими сумами, для перевірки було використано число 123 432. В результаті були отримані наступні часи виконання (в секундах):

- Жадібний алгоритм: `0.016`
- Алгоритм динамічного програмування: `6.38`

## Висновки

За результатами порівняння, було виявлено, що жадібний алгоритм виявився швидшим за алгоритм динамічного програмування для даної задачі.

При великих сумах алгоритм динамічного програмування може займати значно більше часу на обчислення через велику кількість можливих комбінацій монет. З іншого боку, жадібний алгоритм, як правило, працює швидше за рахунок простоти свого підходу, але він може не завжди забезпечувати оптимальний результат.

Отже, вибір між цими двома алгоритмами залежить від конкретного випадку. Якщо час виконання є критичним фактором, а точність не є пріоритетом, то жадібний алгоритм може бути кращим варіантом. Однак, якщо потрібно гарантувати оптимальний результат, а час виконання не є критичним, то алгоритм динамічного програмування буде більш підходящим варіантом.